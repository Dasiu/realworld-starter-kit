@(schema: code_generator.TypeSchema)
package @schema.packageName

import java.time.Instant

import commons.models.{IdMetaModel, Property, WithDateTimes}
import commons.repositories.{BaseId, WithId}
import play.api.libs.json._
import slick.jdbc.MySQLProfile.api.{DBIO => _, MappedTo => _, Rep => _, TableQuery => _, _}

case class @(schema.className) (
    @for((field, index) <- schema.fields.zipWithIndex) {
        @field.name: @field.aType,
    }
    override val createdAt: Instant,
    override val updatedAt: Instant,
    ) extends WithId[Long, @(schema.idClassName)]
          with WithDateTimes[@(schema.className)] {

  override def updateCreatedAt(dateTime: Instant): @(schema.className) = copy(createdAt = dateTime)

  override def updateUpdatedAt(dateTime: Instant): @(schema.className) = copy(updatedAt = dateTime)

}

object @(schema.className) {
  implicit val @(schema.name)Format: Format[@(schema.className)] = Json.format[@(schema.className)]
}

case class @(schema.idClassName)(value: Long) extends AnyVal with BaseId[Long]

object @(schema.idClassName) {
  implicit val @(schema.idVarName)Format: Format[@(schema.idClassName)] = new Format[@(schema.idClassName)] {
    override def reads(json: JsValue): JsResult[@(schema.idClassName)] =
      Reads.LongReads.reads(json).map(@(schema.idClassName)(_))

    override def writes(o: @(schema.idClassName)): JsNumber = Writes.LongWrites.writes(o.value)
  }

  implicit val @(schema.idVarName)DbMapping: BaseColumnType[@(schema.idClassName)] = MappedColumnType.base[@(schema.idClassName), Long](
                                                 vo => vo.value,
                                                 id => @(schema.idClassName)(id)
                                               )
}

object @(schema.metaModelClassName) extends IdMetaModel {
  @for(field <- schema.fields) {
    val @field.name: Property[@field.aType] = Property("@(field.name)")
  }
  val updatedAt: Property[Instant] = Property("updatedAt")

  override type ModelId = @(schema.idClassName)
}